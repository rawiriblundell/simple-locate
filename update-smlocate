#!/bin/sh
# shellcheck disable=SC2006
# Purpose:   Build file lists for use by simple-locate
# Style note: This uses awful backticks for SVR4 compatibility

############################################################
#The MIT License (MIT).
#Copyright (c) 2016 Rawiri Blundell.  

#Permission is hereby granted, free of charge, to any person obtaining
#a copy of this software and associated documentation files (the "Software"), 
#to deal in the Software without restriction, including without limitation 
#the rights to use, copy, modify, merge, publish, distribute, sublicense, 
#and/or sell copies of the Software, and to permit persons to whom the 
#Software is furnished to do so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included 
#in all copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
#OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
#DEALINGS IN THE SOFTWARE.
############################################################

########################################
# If you want to add certain paths to the index, add them here in a space separated list
# Do NOT add trailing slashes e.g. '/opt' = good, '/opt/' = bad
inclPaths="/"

########################################
# Figure out our tmp directory.  We want any existing index files to be available 
# during generation of the new ones.  So we build into tmp then move into place
if [ -d /tmp ]; then
  tmpDir=/tmp
elif [ -d /var/tmp ]; then
  tmpDir=/var/tmp
elif [ -d /usr/tmp ]; then
  tmpDir=/usr/tmp
fi

# This one can't be blank
if [ -z "${tmpDir}" ]; then
  printf "%s\n" "[ERROR] - smlocate: Unable to determine the tmp directory on this system."
  exit 1
fi

########################################
# Cleanup function and traps
cleanup() {
  rm -f "${tmpDir}"/locate.merge
  rm -f "${tmpDir}"/locate.user
  rm -f "${tmpDir}"/locate.user.tmp
  rm -f "${tmpDir}"/locate.root
  rm -f "${tmpDir}"/locate.root.tmp
} 2>/dev/null

# We want to trap on everything
trap cleanup HUP INT QUIT TERM EXIT

########################################
# Select a destination directory
destDir=/var/lib/simple-locate

# Ensure the destination directory exists
if [ ! -d "${destDir}" ]; then
  # If we can't create it, set destDir to tmpDir
  if ! mkdir -p "${destDir}" 2>/dev/null; then
    destDir="${tmpDir}"
    # TO-DO: ensure correct permissions/ownership?
  fi
fi

########################################
# Filesystem types to ignore.  Built up from Linux and Solaris so far...
# Try to keep it alphabetical if you add anything...
exclFS="afs autofs coda ctfs dev devfs devpts fd ftpfs hsfs iso9660 lofs mfs mntfs namefs ncpfs nfs NFS objfs pcfs proc shfs smbfs sysfs tmpfs uvfs"

# We convert this to a find friendly list
# We start by blanking out a new variable
pruneFS=
# Then for each item in the exclFS list, we build up the new variable
for fs in ${exclFS}; do
  pruneFS="${pruneFS} -o -fstype ${fs}"
done
# Now we chop off the unwanted "-o" at the start of the variable
pruneFS=`echo "${pruneFS}" | cut -d " " -f3-`

########################################
# Directory names to ignore.  Built up from Linux and Solaris so far...
# Try to keep it alphabetical if you add anything...
# Note: Slashes will be removed, so don't try to specify e.g. 
# '/tmp /usr/tmp /var/tmp'
# '/tmp' or 'tmp' will work for all three cases
# Slashes will be removed later on as well, so '/var/tmp' would become 'vartmp' which won't match anything
exclPaths="/afs /amd /cdrom /media /proc /sfs /tmp"

# We remove any slashes from exclPaths
exclPaths=`echo "${exclPaths}" | tr -d "/"`

# Now we convert this to a list we can use in find.
# We basically want to convert "/afs /amd ..." 
# to "-o -type d -name afs -o -type d -name amd ..."

# There's very likely a non-portable, very elegant way to do this with 'sed' or 'awk'
prunePaths=
for path in ${exclPaths}; do
  prunePaths="${prunePaths} -o -type d -name ${path}"
done

########################################
# Determine whether or not to use merging format
# If 'false', the indexes will be completely rebuilt each time this update script is run
# If 'true', only directories changed in the last 24 hours will be reindexed
# For most basic usage, 'false' is safer.
mergeIndex=false

################################################################################
# No more editing should be necessary below this line
################################################################################

# If merging is enabled, we need to generate a list of directories
# This builds an egrep filter that we apply to any existing index files
if [ "${mergeIndex}" = true ]; then
  filterDirs=""
  find ${inclPaths} \( ${pruneFS}${prunePaths} \) -prune -o -type d -mtime -1 -print 2>/dev/null > "${tmpDir}"/locate.merge
  
  # shellcheck disable=SC2162
  while IFS= read dir; do
    filterDirs="|${dir}${filterDirs}"
  done < "${tmpDir}"/locate.merge

  # We no longer need the temporary file
  rm -f "${tmpDir}"/locate.merge 2>/dev/null

  # Now we chop off the unwanted "|" at the start of the variable
  filterDirs=`echo "${filterDirs}" | cut -d "|" -f2-`

  # We also generate a find friendly list
  inclPaths=`echo "${filterDirs}" | tr "|" " "`

  # If the root index file exists and is writeable by us (i.e. we're root)...
  # We filter out the modified directories from the current index
  if [ -w "${destDir}"/locate.root ]; then
    egrep -v "${filterDirs}" "${destDir}"/locate.root > "${tmpDir}"/locate.root.tmp
    # Now we reindex only those directories and append to the .tmp file
    # shellcheck disable=SC2086
    find ${inclPaths} \( ${pruneFS}${prunePaths} \) -prune -o -print 2>/dev/null >> "${tmpDir}"/locate.root.tmp

    # And finally move the .tmp file into place for the rest of the script
    mv "${tmpDir}"/locate.root.tmp "${tmpDir}"/locate.root
  fi
  # And/or otherwise, act on the user index file
  if [ -f "${destDir}"/locate.user ]; then
    egrep -v "${filterDirs}" "${destDir}"/locate.user > "${tmpDir}"/locate.user.tmp
    
    # Create our user-readable file. This should remove most files that aren't 
    # accessible to users, without needing to stat/test every file
    # We need to figure out if 'su' requires '-s'.  This issue was found on, surprise: Solaris
    # First we test if "true" returns 0, if so we can go ahead with this style
    if su nobody -c "true" > /dev/null 2>&1; then
      su nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null >> ${tmpDir}/locate.user.tmp"
    # Next, we try '-s', we use '-s' to override /bin/false or /bin/nologin
    elif su nobody -s /bin/sh -c "true" > /dev/null 2>&1; then
      su nobody -s /bin/sh -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null >> ${tmpDir}/locate.user.tmp"
    # Put in handling for FreeBSD
    elif [ "`uname`" = FreeBSD ]; then
      su -m nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print" >> ${tmpDir}/locate.user.tmp 2>/dev/null
    # If nothing works, print a notification, then fail back to nothing and hope for the best
    else
      printf "%s\n" "[INFO] - smlocate: Unable to determine if 'su' on this host requires '-s /bin/sh'" \
        "Proceeding on the assumption that it does not.  YMMV."
      su nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null >> ${tmpDir}/locate.user.tmp"
    fi
    
    mv "${tmpDir}"/locate.user.tmp "${tmpDir}"/locate.user
  fi

# Else, if merging is not enabled, we perform a full index.
else
  ########################################
  # If we're running as root, we can generate both files
  if [ -w / ]; then
    # Create our root-readable files
    # shellcheck disable=SC2086
    find ${inclPaths} \( ${pruneFS}${prunePaths} \) -prune -o -print 2>/dev/null > "${tmpDir}"/locate.root

    # Now create our user-readable file.  See comments above.
    if su nobody -c "true" > /dev/null 2>&1; then
      su nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null > ${tmpDir}/locate.user"
    elif su nobody -s /bin/sh -c "true" > /dev/null 2>&1; then
      su nobody -s /bin/sh -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null > ${tmpDir}/locate.user"
    elif [ "`uname`" = FreeBSD ]; then
      su -m nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print" > ${tmpDir}/locate.user 2>/dev/null
    else
      printf "%s\n" "[INFO] - smlocate: Unable to determine if 'su' on this host requires '-s /bin/sh'" \
        "Proceeding on the assumption that it does not.  YMMV."
      su nobody -c "find ${inclPaths} \\( ${pruneFS}${prunePaths} \\) -prune -o -print 2>/dev/null > ${tmpDir}/locate.user"
    fi

  # Otherwise, we just generate what we can (i.e. manual run)
  # This will list files limited to the invocating user
  else
    printf "%s\n" "[INFO] - smlocate: building index now, this may take a while..."
    # Obviously if a merge file is there, we act appropriately
    if [ -f "${tmpDir}"/locate.user.tmp ]; then
      # shellcheck disable=SC2086
      find ${inclPaths} \( ${pruneFS}${prunePaths} \) -prune -o -print 2>/dev/null >> "${tmpDir}"/locate.user.tmp
      mv "${tmpDir}"/locate.user.tmp "${tmpDir}"/locate.user
    else
      # shellcheck disable=SC2086
      find ${inclPaths} \( ${pruneFS}${prunePaths} \) -prune -o -print 2>/dev/null > "${tmpDir}"/locate.user
    fi
  fi
fi

# Ensure correct ownership and permissions
chown 0:0 "${tmpDir}"/locate.root 2>/dev/null
chmod 440 "${tmpDir}"/locate.root 2>/dev/null
chmod 444 "${tmpDir}"/locate.user

# If tmpDir and destDir are different, move the tmp files to the destination
if [ ! "${tmpDir}" = "${destDir}" ]; then
  mv "${tmpDir}"/locate.root "${destDir}"
  mv "${tmpDir}"/locate.user "${destDir}"
fi
